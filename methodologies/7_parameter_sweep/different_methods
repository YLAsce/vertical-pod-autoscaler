cpu==============
非常简单：均匀sweep 8，然后筛选：
    # if result['cpu-overrun-seconds'] > 20000:
    #     continue
    # if result['cpu-request-adjust-times'] > 600:
    #     continue

然后就得到了规律了（三个param都是0），
{'cpu-average-gap': 237.6150948965105, 'cpu-overrun-seconds': 16118, 'cpu-request-adjust-times': 143}
-  {'ap-ml-cpu-hyperparam-d': 0.8571428571428571, 'ap-ml-cpu-hyperparam-wdeltal': 0.0, 'ap-ml-cpu-hyperparam-wdeltam': 0.0, 'ap-ml-cpu-hyperparam-wo': 0.14285714285714285, 'ap-ml-cpu-hyperparam-wu': 0.0}
再在这两个维度上加详细扫描：
		-ap-ml-cpu-hyperparam-d=0.8571428571428571 \
		-ap-ml-cpu-hyperparam-wdeltal=0.0 \
		-ap-ml-cpu-hyperparam-wdeltam=0.0 \
		-ap-ml-cpu-hyperparam-wo=0.14285714285714285 \

效果：Figure_compare_bestcpumem_v2_2_random.png



Memory=============
目标：
"memory-average-gap":261822531.09440148
"memory-overrun-seconds":301
"memory-request-adjust-times":64

第一种：均匀param_sweep：筛选结果：（400， 100）（overrun，adjust）
{'memory-average-gap': 332902801.9694568, 'memory-overrun-seconds': 360, 'oom-seconds': 28,'memory-request-adjust-times': 57}
-  {'ap-ml-memory-hyperparam-d': 0.7142857142857142, 'ap-ml-memory-hyperparam-wdeltal': 0.14285714285714285, 'ap-ml-memory-hyperparam-wdeltam': 0.7142857142857142, 'ap-ml-memory-hyperparam-wo': 0.8571428571428571, 'ap-ml-memory-hyperparam-wu': 0.0}

第二种：先random再descent（find）：筛选条件：（2000，1000）
大概有6种局部最优点，在文件夹find中

第三种：纯random：
big的overrun限制是2000，small的是500，8000和bestmemory的是8000
adjust设置为500或者1000，不是bottleneck
问题是big的并没有random出来，可能是时间短，剩下的时间再跑一跑8000或者10000的superbig的？///

第四种：先手动制定规则，再跑pattern（halfsweep）
overrun限制有两个档次：8000的和10000的。adjust限制始终是100



CONVEX========
固定所有维度到先前sweep到的最优解，然后探索每一个维度的影响

最后一种：用Q learning，状态是五个hyperparam，action fixed，现在要学习的是输出如何反过来影响hyperparam的调节。也就是Q值
仍然有问题：state space过大且连续，本质上和上面是同一个问题。没绕开